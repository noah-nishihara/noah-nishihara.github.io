
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>OTHELLO: NEBULA — Fog-of-War + Drifting Craters</title>
<style>
  :root{
    --bg0:#050816;
    --bg1:#070a22;
    --panel: rgba(10,14,40,.65);
    --panel2: rgba(12,18,60,.55);
    --line: rgba(160,190,255,.25);
    --text: rgba(235,245,255,.92);
    --muted: rgba(235,245,255,.65);
    --accent: #72f7ff;
    --accent2:#b47cff;

    --cell: clamp(34px, 6.3vw, 66px);
    --gap: clamp(6px, 0.9vw, 10px);
    --radius: 16px;

    --black1: #0c0f1a;
    --black2: #1b2240;

    --white1: #e9f3ff;
    --white2: #b9d4ff;

    --crater1:#2a2c39;
    --crater2:#161722;
    --craterGlow:#ffb86b;
  }

  /* Cosmic background */
  body{
    margin:0;
    font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial, sans-serif;
    color: var(--text);
    background:
      radial-gradient(1400px 900px at 20% 10%, rgba(125,85,255,.18), transparent 60%),
      radial-gradient(1200px 800px at 80% 20%, rgba(120,255,240,.12), transparent 60%),
      radial-gradient(900px 700px at 50% 90%, rgba(255,155,85,.10), transparent 55%),
      linear-gradient(180deg, var(--bg0), var(--bg1));
    min-height:100svh;
    overflow-x:hidden;
  }
  .stars::before, .stars::after{
    content:"";
    position:fixed;
    inset:-30%;
    background-image:
      radial-gradient(2px 2px at 12% 22%, rgba(255,255,255,.65), transparent 60%),
      radial-gradient(1px 1px at 30% 60%, rgba(255,255,255,.55), transparent 60%),
      radial-gradient(1px 1px at 73% 18%, rgba(255,255,255,.55), transparent 60%),
      radial-gradient(2px 2px at 80% 70%, rgba(255,255,255,.65), transparent 60%),
      radial-gradient(1px 1px at 55% 42%, rgba(255,255,255,.55), transparent 60%),
      radial-gradient(2px 2px at 45% 82%, rgba(255,255,255,.55), transparent 60%);
    opacity:.55;
    transform: translateZ(0);
    animation: drift 40s linear infinite;
    pointer-events:none;
  }
  .stars::after{
    opacity:.35;
    filter: blur(.4px);
    animation-duration: 70s;
    animation-direction: reverse;
  }
  @keyframes drift{
    from{ transform: translate(-2%, -2%) scale(1.02); }
    to{ transform: translate(2%, 2%) scale(1.02); }
  }

  header{
    max-width: 1100px;
    margin: 26px auto 12px;
    padding: 0 16px;
    display:flex;
    gap: 16px;
    align-items:flex-end;
    justify-content: space-between;
  }
  .title{
    line-height:1.05;
  }
  .title h1{
    margin:0;
    font-size: clamp(22px, 2.8vw, 36px);
    letter-spacing: .04em;
    font-weight: 780;
    text-transform: uppercase;
  }
  .title .sub{
    margin-top: 6px;
    color: var(--muted);
    font-size: clamp(12px, 1.35vw, 14px);
  }
  .badge{
    display:inline-flex;
    gap: 8px;
    align-items:center;
    padding: 8px 12px;
    border: 1px solid var(--line);
    border-radius: 999px;
    background: linear-gradient(180deg, rgba(120,255,240,.10), rgba(180,124,255,.08));
    box-shadow: 0 10px 25px rgba(0,0,0,.25);
    backdrop-filter: blur(6px);
    font-size: 12px;
    color: rgba(245,252,255,.9);
    user-select:none;
  }
  .dot{
    width: 9px; height: 9px;
    border-radius:999px;
    background: radial-gradient(circle at 30% 30%, #fff, var(--accent));
    box-shadow: 0 0 12px rgba(114,247,255,.7);
  }

  main{
    max-width: 1100px;
    margin: 0 auto 26px;
    padding: 0 16px 22px;
    display:grid;
    grid-template-columns: 1fr 340px;
    gap: 16px;
  }
  @media (max-width: 980px){
    main{ grid-template-columns: 1fr; }
  }

  .boardCard{
    position:relative;
    border: 1px solid var(--line);
    background: linear-gradient(180deg, rgba(16,22,70,.55), rgba(9,12,40,.55));
    border-radius: var(--radius);
    overflow:hidden;
    box-shadow: 0 20px 60px rgba(0,0,0,.35);
  }

  .boardTop{
    display:flex;
    gap: 10px;
    justify-content: space-between;
    align-items:center;
    padding: 14px 14px 10px;
    border-bottom: 1px solid rgba(160,190,255,.16);
    background: linear-gradient(180deg, rgba(14,18,60,.55), rgba(14,18,60,.18));
  }
  .turn{
    display:flex;
    gap: 10px;
    align-items:center;
  }
  .turn .who{
    font-weight: 700;
    letter-spacing:.03em;
  }
  .pill{
    display:inline-flex;
    align-items:center;
    gap: 8px;
    padding: 7px 10px;
    border: 1px solid rgba(160,190,255,.20);
    border-radius: 999px;
    background: rgba(0,0,0,.18);
    color: rgba(245,252,255,.92);
    font-size: 12px;
  }
  .discTiny{
    width: 14px; height: 14px;
    border-radius:999px;
    box-shadow: 0 0 10px rgba(0,0,0,.35);
  }
  .discTiny.black{
    background: radial-gradient(circle at 30% 30%, #556, var(--black1) 55%, var(--black2));
  }
  .discTiny.white{
    background: radial-gradient(circle at 30% 30%, #fff, var(--white1) 55%, var(--white2));
  }

  .boardWrap{
    position:relative;
    padding: 16px;
  }
  .grid{
    display:grid;
    grid-template-columns: repeat(8, var(--cell));
    grid-template-rows: repeat(8, var(--cell));
    gap: var(--gap);
    width: max-content;
    margin: 0 auto;
    padding: 14px;
    border-radius: calc(var(--radius) + 8px);
    background:
      radial-gradient(800px 450px at 50% 30%, rgba(114,247,255,.12), transparent 60%),
      radial-gradient(700px 420px at 20% 90%, rgba(180,124,255,.10), transparent 58%),
      linear-gradient(180deg, rgba(5,9,26,.75), rgba(5,7,20,.80));
    border: 1px solid rgba(160,190,255,.20);
    box-shadow:
      inset 0 0 0 1px rgba(255,255,255,.04),
      0 25px 55px rgba(0,0,0,.35);
    position:relative;
  }

  .cell{
    position:relative;
    border-radius: 14px;
    border: 1px solid rgba(160,190,255,.14);
    background:
      radial-gradient(100px 70px at 30% 20%, rgba(255,255,255,.05), transparent 60%),
      radial-gradient(80px 60px at 90% 80%, rgba(114,247,255,.05), transparent 55%),
      rgba(0,0,0,.20);
    overflow:hidden;
    cursor:pointer;
    user-select:none;
    transform: translateZ(0);
  }
  .cell:hover{
    border-color: rgba(114,247,255,.35);
    box-shadow: 0 0 0 2px rgba(114,247,255,.10);
  }

  /* Nebula fog for hidden cells */
  .cell.fog{
    cursor:not-allowed;
    border-color: rgba(160,190,255,.09);
    background:
      radial-gradient(80px 60px at 20% 20%, rgba(180,124,255,.10), transparent 55%),
      radial-gradient(110px 80px at 80% 60%, rgba(114,247,255,.08), transparent 60%),
      linear-gradient(180deg, rgba(10,12,30,.65), rgba(0,0,0,.35));
    filter: saturate(0.85) contrast(0.95);
  }
  .cell.fog::after{
    content:"";
    position:absolute; inset:-40%;
    background:
      radial-gradient(2px 2px at 20% 30%, rgba(255,255,255,.35), transparent 60%),
      radial-gradient(1px 1px at 70% 55%, rgba(255,255,255,.28), transparent 60%),
      radial-gradient(1px 1px at 40% 80%, rgba(255,255,255,.24), transparent 60%);
    opacity:.55;
    animation: fogflow 10s linear infinite;
    pointer-events:none;
  }
  @keyframes fogflow{
    from{ transform: translate(-6%, -4%) rotate(0deg); }
    to{ transform: translate(6%, 4%) rotate(8deg); }
  }

  /* Disc */
  .disc{
    position:absolute;
    inset: 10%;
    border-radius: 999px;
    transform-style: preserve-3d;
    box-shadow: 0 12px 20px rgba(0,0,0,.35);
  }
  .disc.black{
    background: radial-gradient(circle at 30% 30%, #637, var(--black1) 55%, var(--black2));
    outline: 1px solid rgba(255,255,255,.10);
  }
  .disc.white{
    background: radial-gradient(circle at 30% 30%, #fff, var(--white1) 55%, var(--white2));
    outline: 1px solid rgba(0,0,0,.06);
  }
  /* Flip animation */
  .flip{
    animation: flip 420ms ease-in-out both;
  }
  @keyframes flip{
    0%{ transform: rotateY(0deg) scale(1); filter: brightness(1); }
    45%{ transform: rotateY(90deg) scale(.92); filter: brightness(1.15); }
    55%{ transform: rotateY(90deg) scale(.92); filter: brightness(1.10); }
    100%{ transform: rotateY(180deg) scale(1); filter: brightness(1); }
  }

  /* Hint marker */
  .hint{
    position:absolute;
    inset: 26%;
    border-radius:999px;
    border: 2px dashed rgba(114,247,255,.75);
    box-shadow: 0 0 20px rgba(114,247,255,.20);
    opacity:.95;
    animation: pulse 1.25s ease-in-out infinite;
    pointer-events:none;
  }
  @keyframes pulse{
    0%,100%{ transform: scale(.95); opacity:.65; }
    50%{ transform: scale(1.05); opacity:1; }
  }

  /* Crater */
  .crater{
    position:absolute;
    inset: 16%;
    border-radius: 999px;
    background:
      radial-gradient(circle at 30% 25%, rgba(255,200,125,.35), transparent 40%),
      radial-gradient(circle at 55% 55%, var(--crater1), var(--crater2));
    border: 1px solid rgba(255,184,107,.22);
    box-shadow:
      inset -6px -10px 16px rgba(0,0,0,.35),
      0 0 22px rgba(255,184,107,.18);
  }
  .crater::after{
    content:"";
    position:absolute; inset: 18% 24% 28% 18%;
    border-radius:999px;
    background: radial-gradient(circle at 35% 35%, rgba(0,0,0,.35), rgba(0,0,0,.02));
    filter: blur(.2px);
    opacity:.85;
  }

  .side{
    display:flex;
    flex-direction:column;
    gap: 12px;
  }
  .panel{
    border: 1px solid var(--line);
    background: linear-gradient(180deg, var(--panel), rgba(8,10,28,.55));
    border-radius: var(--radius);
    box-shadow: 0 18px 55px rgba(0,0,0,.28);
    overflow:hidden;
  }
  .panel h2{
    margin:0;
    font-size: 13px;
    letter-spacing:.12em;
    text-transform: uppercase;
    padding: 12px 12px 10px;
    border-bottom: 1px solid rgba(160,190,255,.14);
    color: rgba(245,252,255,.86);
    background: linear-gradient(180deg, rgba(12,18,60,.38), rgba(12,18,60,.10));
  }
  .panel .content{
    padding: 12px;
    color: rgba(245,252,255,.86);
    font-size: 13px;
    line-height:1.4;
  }

  .row{
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap: 10px;
    padding: 8px 0;
    border-bottom: 1px dashed rgba(160,190,255,.14);
  }
  .row:last-child{ border-bottom:0; }

  .btns{
    display:flex;
    flex-wrap:wrap;
    gap: 8px;
    padding-top: 4px;
  }
  button, select, input[type="checkbox"]{
    font: inherit;
  }
  button{
    appearance:none;
    border: 1px solid rgba(160,190,255,.22);
    background: linear-gradient(180deg, rgba(255,255,255,.08), rgba(0,0,0,.18));
    color: rgba(245,252,255,.92);
    border-radius: 12px;
    padding: 9px 10px;
    cursor:pointer;
    transition: transform .06s ease, border-color .2s ease, filter .2s ease;
  }
  button:hover{
    border-color: rgba(114,247,255,.45);
    filter: brightness(1.06);
  }
  button:active{ transform: translateY(1px); }
  button.primary{
    border-color: rgba(114,247,255,.55);
    box-shadow: 0 0 0 3px rgba(114,247,255,.10);
  }
  button.danger{
    border-color: rgba(255,120,120,.4);
  }
  select{
    width:100%;
    border: 1px solid rgba(160,190,255,.22);
    background: rgba(0,0,0,.18);
    color: rgba(245,252,255,.92);
    border-radius: 12px;
    padding: 9px 10px;
    outline:none;
  }
  label.toggle{
    display:flex;
    gap: 10px;
    align-items:center;
    cursor:pointer;
  }
  .small{
    font-size: 12px;
    color: var(--muted);
  }
  .scoreline{
    display:flex;
    gap: 10px;
    align-items:center;
    justify-content:space-between;
  }
  .score{
    display:flex;
    gap: 10px;
    align-items:center;
  }
  .score strong{
    font-size: 16px;
    letter-spacing:.02em;
  }
  .log{
    max-height: 210px;
    overflow:auto;
    padding-right: 4px;
  }
  .log .item{
    padding: 7px 0;
    border-bottom: 1px dashed rgba(160,190,255,.14);
    display:flex;
    justify-content:space-between;
    gap: 10px;
    font-size: 12px;
    color: rgba(245,252,255,.84);
  }
  .log .item:last-child{ border-bottom:0; }
  .mono{
    font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
    letter-spacing:.02em;
  }

  /* Hotseat curtain for Nebula mode */
  .curtain{
    position:absolute;
    inset:0;
    display:none;
    place-items:center;
    background:
      radial-gradient(800px 500px at 50% 40%, rgba(114,247,255,.12), transparent 60%),
      radial-gradient(900px 600px at 30% 70%, rgba(180,124,255,.12), transparent 60%),
      rgba(0,0,0,.70);
    backdrop-filter: blur(10px);
    z-index: 50;
  }
  .curtain.on{ display:grid; }
  .curtain .card{
    width: min(520px, 90%);
    border: 1px solid rgba(160,190,255,.25);
    border-radius: 18px;
    background: linear-gradient(180deg, rgba(12,18,60,.70), rgba(0,0,0,.35));
    box-shadow: 0 30px 80px rgba(0,0,0,.55);
    padding: 18px 16px 16px;
    text-align:center;
  }
  .curtain h3{
    margin:0 0 8px;
    font-size: 16px;
    letter-spacing:.06em;
    text-transform: uppercase;
  }
  .curtain p{ margin: 0 0 12px; color: rgba(245,252,255,.82); }
  .curtain .bigDisc{
    width: 58px; height: 58px;
    margin: 10px auto 14px;
    border-radius:999px;
    box-shadow: 0 14px 28px rgba(0,0,0,.45);
  }
  .bigDisc.black{
    background: radial-gradient(circle at 30% 30%, #778, var(--black1) 55%, var(--black2));
  }
  .bigDisc.white{
    background: radial-gradient(circle at 30% 30%, #fff, var(--white1) 55%, var(--white2));
  }

  .toast{
    position: fixed;
    left: 50%;
    bottom: 18px;
    transform: translateX(-50%);
    padding: 10px 12px;
    border-radius: 999px;
    background: rgba(0,0,0,.45);
    border: 1px solid rgba(160,190,255,.25);
    color: rgba(245,252,255,.92);
    box-shadow: 0 18px 55px rgba(0,0,0,.35);
    opacity: 0;
    pointer-events:none;
    transition: opacity .18s ease, transform .18s ease;
    z-index: 100;
    font-size: 13px;
  }
  .toast.on{
    opacity:1;
    transform: translateX(-50%) translateY(-2px);
  }
</style>
</head>
<body class="stars">
<header>
  <div class="title">
    <h1>OTHELLO: NEBULA</h1>
    <div class="sub">Classic flips. New universe: <b>Fog‑of‑War Hotseat</b> + <b>Drifting Craters</b>.</div>
  </div>
  <div class="badge" title="A creative Othello variant in one HTML file.">
    <span class="dot"></span>
    <span class="mono">v1.0</span>
    <span>single‑file</span>
  </div>
</header>

<main>
  <section class="boardCard">
    <div class="boardTop">
      <div class="turn">
        <span class="pill">
          <span id="turnDisc" class="discTiny black"></span>
          <span class="who" id="turnText">Black to move</span>
        </span>
        <span class="pill" title="Moves made so far">
          ⟡ Turn <span class="mono" id="turnNum">1</span>
        </span>
        <span class="pill" title="Crater drift status">
          ☄ <span class="mono" id="craterStatus">off</span>
        </span>
      </div>
      <div class="pill" id="statusPill">Find a line to flip.</div>
    </div>

    <div class="boardWrap">
      <div id="grid" class="grid" aria-label="Othello board"></div>

      <div id="curtain" class="curtain" role="dialog" aria-modal="true" aria-label="Pass device curtain">
        <div class="card">
          <h3>Pass the device</h3>
          <div id="curtainDisc" class="bigDisc black"></div>
          <p id="curtainText">Next: Black (fog-of-war active)</p>
          <div class="btns" style="justify-content:center;">
            <button class="primary" id="revealBtn">Reveal & Continue</button>
          </div>
          <div class="small" style="margin-top:10px;">
            Nebula mode hides distant squares so hotseat is playable without peeking.
          </div>
        </div>
      </div>
    </div>
  </section>

  <aside class="side">
    <section class="panel">
      <h2>Controls</h2>
      <div class="content">
        <div class="row">
          <div>
            <div><b>Mode</b></div>
            <div class="small">Hotseat or vs AI (White).</div>
          </div>
          <div style="min-width: 150px;">
            <select id="modeSel">
              <option value="hotseat">Hotseat (2 players)</option>
              <option value="ai">Vs AI (You=Black, AI=White)</option>
            </select>
          </div>
        </div>

        <div class="row">
          <label class="toggle">
            <input type="checkbox" id="nebulaChk" checked />
            <div>
              <div><b>Nebula (Fog‑of‑War + Curtain)</b></div>
              <div class="small">Only nearby squares are visible per turn.</div>
            </div>
          </label>
        </div>

        <div class="row">
          <label class="toggle">
            <input type="checkbox" id="craterChk" />
            <div>
              <div><b>Crater Drift</b></div>
              <div class="small">Obstacles spawn and drift toward center.</div>
            </div>
          </label>
        </div>

        <div class="row">
          <div style="width:100%">
            <div class="btns">
              <button id="hintBtn">Hint</button>
              <button id="undoBtn">Undo</button>
              <button id="restartBtn" class="danger">Restart</button>
            </div>
          </div>
        </div>

        <div class="small">
          <b>Rule core:</b> Place a disc that brackets opponent discs in any direction; bracketed discs flip. If you have no legal moves, you pass. Game ends when both pass.
        </div>
      </div>
    </section>

    <section class="panel">
      <h2>Score + Telemetry</h2>
      <div class="content">
        <div class="scoreline">
          <div class="score">
            <span class="discTiny black"></span>
            <strong id="scoreB">2</strong>
            <span class="small">Black</span>
          </div>
          <div class="score">
            <span class="discTiny white"></span>
            <strong id="scoreW">2</strong>
            <span class="small">White</span>
          </div>
        </div>
        <div class="row">
          <div>
            <div><b>Legal moves</b></div>
            <div class="small">For current player.</div>
          </div>
          <div class="mono" id="legalCount">4</div>
        </div>
        <div class="row">
          <div>
            <div><b>AI style</b></div>
            <div class="small">Greedy + mobility.</div>
          </div>
          <div class="mono" id="aiInfo">—</div>
        </div>
      </div>
    </section>

    <section class="panel">
      <h2>Chronicle (Move Log)</h2>
      <div class="content">
        <div id="log" class="log"></div>
      </div>
    </section>
  </aside>
</main>

<div id="toast" class="toast"></div>

<script>
(() => {
  const N = 8;
  const dirs = [
    [-1,-1], [-1,0], [-1,1],
    [0,-1],          [0,1],
    [1,-1],  [1,0],  [1,1]
  ];

  // UI elements
  const gridEl = document.getElementById('grid');
  const turnText = document.getElementById('turnText');
  const turnDisc = document.getElementById('turnDisc');
  const turnNumEl = document.getElementById('turnNum');
  const statusPill = document.getElementById('statusPill');
  const scoreBEl = document.getElementById('scoreB');
  const scoreWEl = document.getElementById('scoreW');
  const legalCountEl = document.getElementById('legalCount');
  const aiInfoEl = document.getElementById('aiInfo');
  const logEl = document.getElementById('log');
  const toastEl = document.getElementById('toast');

  const modeSel = document.getElementById('modeSel');
  const nebulaChk = document.getElementById('nebulaChk');
  const craterChk = document.getElementById('craterChk');
  const craterStatusEl = document.getElementById('craterStatus');

  const hintBtn = document.getElementById('hintBtn');
  const undoBtn = document.getElementById('undoBtn');
  const restartBtn = document.getElementById('restartBtn');

  const curtainEl = document.getElementById('curtain');
  const revealBtn = document.getElementById('revealBtn');
  const curtainDisc = document.getElementById('curtainDisc');
  const curtainText = document.getElementById('curtainText');

  // Game state
  let board, current, turnNo, passes, showHints;
  let history = []; // snapshots for undo
  let log = [];
  let lastMove = null;

  // Crater Drift state
  let craterOn = false;
  let crater = null; // {r,c}
  let craterSpawnEvery = 6; // spawn attempt every 6 turns
  let craterSpawnedAtTurn = null;

  // For Nebula curtain usage (hotseat only)
  let curtainPending = false;

  // Build grid
  const cellEls = [];
  for (let r=0;r<N;r++){
    for (let c=0;c<N;c++){
      const cell = document.createElement('div');
      cell.className = 'cell';
      cell.tabIndex = 0;
      cell.setAttribute('role','button');
      cell.setAttribute('aria-label', `Cell ${r+1},${c+1}`);
      cell.dataset.r = r;
      cell.dataset.c = c;
      cell.addEventListener('click', () => onCell(r,c));
      cell.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); onCell(r,c); }
      });
      gridEl.appendChild(cell);
      cellEls.push(cell);
    }
  }

  function cloneBoard(b){
    return b.map(row => row.slice());
  }
  function other(p){ return p==='B' ? 'W' : 'B'; }
  function inb(r,c){ return r>=0 && r<N && c>=0 && c<N; }

  function reset(){
    board = Array.from({length:N}, () => Array(N).fill(null));
    board[3][3] = 'W';
    board[3][4] = 'B';
    board[4][3] = 'B';
    board[4][4] = 'W';
    current = 'B';
    turnNo = 1;
    passes = 0;
    showHints = false;
    history = [];
    log = [];
    lastMove = null;

    craterOn = craterChk.checked;
    crater = null;
    craterSpawnedAtTurn = null;
    craterStatusEl.textContent = craterOn ? "armed" : "off";

    pushHistory("Start");
    render(true);
    maybeAIMove();
  }

  function pushHistory(reason){
    history.push({
      board: cloneBoard(board),
      current,
      turnNo,
      passes,
      showHints,
      craterOn,
      crater: crater ? {...crater} : null,
      craterSpawnedAtTurn,
      log: log.slice(),
      lastMove: lastMove ? {...lastMove} : null,
      reason
    });
    if (history.length > 80) history.shift();
  }

  function popHistory(){
    if (history.length <= 1) return; // keep initial
    history.pop();
    const s = history[history.length-1];
    board = cloneBoard(s.board);
    current = s.current;
    turnNo = s.turnNo;
    passes = s.passes;
    showHints = s.showHints;
    craterOn = s.craterOn;
    crater = s.crater ? {...s.crater} : null;
    craterSpawnedAtTurn = s.craterSpawnedAtTurn;
    log = s.log.slice();
    lastMove = s.lastMove ? {...s.lastMove} : null;
    craterStatusEl.textContent = craterOn ? (crater ? "drifting" : "armed") : "off";
    render(true);
  }

  function legalMovesFor(player){
    const opp = other(player);
    const moves = new Map(); // key "r,c" -> flips array
    for (let r=0;r<N;r++){
      for (let c=0;c<N;c++){
        if (board[r][c] !== null) continue;
        let flipsAll = [];
        for (const [dr,dc] of dirs){
          let rr=r+dr, cc=c+dc;
          let flips = [];
          while (inb(rr,cc) && board[rr][cc] === opp){
            flips.push([rr,cc]);
            rr += dr; cc += dc;
          }
          if (flips.length && inb(rr,cc) && board[rr][cc] === player){
            flipsAll = flipsAll.concat(flips);
          }
        }
        if (flipsAll.length){
          moves.set(r+","+c, flipsAll);
        }
      }
    }
    return moves;
  }

  function applyMove(r,c, flips){
    board[r][c] = current;
    for (const [rr,cc] of flips){
      board[rr][cc] = current;
    }
  }

  function countScore(){
    let b=0,w=0;
    for (let r=0;r<N;r++){
      for (let c=0;c<N;c++){
        if (board[r][c]==='B') b++;
        else if (board[r][c]==='W') w++;
      }
    }
    return {b,w};
  }

  // Nebula visibility: show cells within Chebyshev dist<=2 of any disc of current player,
  // plus legal move cells, plus crater cell (so you can see the obstacle).
  function computeVisible(player, moves){
    const vis = Array.from({length:N}, () => Array(N).fill(false));
    for (let r=0;r<N;r++){
      for (let c=0;c<N;c++){
        if (board[r][c] === player){
          for (let rr=r-2; rr<=r+2; rr++){
            for (let cc=c-2; cc<=c+2; cc++){
              if (inb(rr,cc)) vis[rr][cc] = true;
            }
          }
        }
      }
    }
    for (const key of moves.keys()){
      const [r,c] = key.split(',').map(Number);
      vis[r][c] = true;
    }
    if (crater) vis[crater.r][crater.c] = true;
    return vis;
  }

  function render(force=false){
    const moves = legalMovesFor(current);
    const {b,w} = countScore();
    scoreBEl.textContent = b;
    scoreWEl.textContent = w;
    legalCountEl.textContent = moves.size;
    turnNumEl.textContent = turnNo;

    const isAI = modeSel.value === 'ai';
    aiInfoEl.textContent = isAI ? "White" : "—";

    // Turn label
    const name = current === 'B' ? 'Black' : 'White';
    turnText.textContent = `${name} to move`;
    turnDisc.classList.toggle('black', current==='B');
    turnDisc.classList.toggle('white', current==='W');

    // Status
    if (moves.size === 0){
      statusPill.textContent = "No legal moves: pass.";
    } else {
      statusPill.textContent = showHints ? "Hints ON: glowing rings are legal moves." : "Find a line to flip.";
    }

    // Nebula fog visibility
    const nebulaOn = nebulaChk.checked;
    const vis = nebulaOn ? computeVisible(current, moves) : null;

    // Paint cells
    for (let r=0;r<N;r++){
      for (let c=0;c<N;c++){
        const idx = r*N + c;
        const cell = cellEls[idx];
        const val = board[r][c];

        // Fog class
        const fog = nebulaOn && !vis[r][c];
        cell.classList.toggle('fog', fog);

        // Clear children
        while(cell.firstChild) cell.removeChild(cell.firstChild);

        // Add crater/disc/hint
        if (val === 'X'){
          const cr = document.createElement('div');
          cr.className = 'crater';
          cell.appendChild(cr);
        } else if (val === 'B' || val === 'W'){
          // If fog, still show "nothing" (hidden)
          if (!fog){
            const d = document.createElement('div');
            d.className = 'disc ' + (val==='B' ? 'black' : 'white');
            cell.appendChild(d);
          }
        } else {
          // Empty
          if (!fog && showHints && moves.has(r+","+c)){
            const h = document.createElement('div');
            h.className = 'hint';
            cell.appendChild(h);
          }
        }

        // Cursor & hover for legal moves (only if visible & not crater)
        const isLegal = moves.has(r+","+c);
        cell.style.cursor = (!fog && isLegal) ? 'pointer' : (fog ? 'not-allowed' : 'default');
      }
    }

    // Render log
    logEl.innerHTML = "";
    for (let i=0;i<log.length;i++){
      const it = document.createElement('div');
      it.className = 'item';
      it.innerHTML = `<span class="mono">${String(i+1).padStart(2,'0')}</span>
                      <span>${log[i]}</span>`;
      logEl.appendChild(it);
    }
    logEl.scrollTop = logEl.scrollHeight;

    craterStatusEl.textContent = craterOn ? (crater ? "drifting" : "armed") : "off";
  }

  function coordLabel(r,c){
    // chess-like: a1 bottom-left; but for simplicity use a-h and 1-8 with 1 at top
    const file = String.fromCharCode(97 + c); // a..h
    const rank = (r+1);
    return file + rank;
  }

  function toast(msg){
    toastEl.textContent = msg;
    toastEl.classList.add('on');
    clearTimeout(toastEl._t);
    toastEl._t = setTimeout(() => toastEl.classList.remove('on'), 1300);
  }

  function endIfOver(){
    const m1 = legalMovesFor('B').size;
    const m2 = legalMovesFor('W').size;
    if (m1===0 && m2===0){
      const {b,w} = countScore();
      let winner = b===w ? "Draw" : (b>w ? "Black wins" : "White wins");
      statusPill.textContent = `Game over — ${winner}.`;
      toast(`Game over — ${winner}.`);
      return true;
    }
    return false;
  }

  // -------- Crater Drift mechanics --------
  function distToCenter(r,c){
    const cr = (N-1)/2, cc = (N-1)/2;
    const dr = r-cr, dc=c-cc;
    return Math.sqrt(dr*dr + dc*dc);
  }
  function seededRand(seed){
    // simple LCG (deterministic)
    let x = (seed >>> 0) + 0x9e3779b9;
    x = (x ^ (x >>> 16)) >>> 0;
    x = (x * 0x7feb352d) >>> 0;
    x = (x ^ (x >>> 15)) >>> 0;
    x = (x * 0x846ca68b) >>> 0;
    x = (x ^ (x >>> 16)) >>> 0;
    return x / 2**32;
  }
  function chooseCraterSpawn(){
    // Choose an empty cell farthest from center; tie-break by seededRand(turnNo)
    let best = [];
    let bestD = -1;
    for (let r=0;r<N;r++){
      for (let c=0;c<N;c++){
        if (board[r][c] !== null) continue;
        const d = distToCenter(r,c);
        if (d > bestD + 1e-9){
          bestD = d;
          best = [[r,c]];
        } else if (Math.abs(d-bestD) < 1e-9){
          best.push([r,c]);
        }
      }
    }
    if (!best.length) return null;
    const idx = Math.floor(seededRand(turnNo*1337) * best.length);
    return {r: best[idx][0], c: best[idx][1]};
  }
  function spawnCraterIfNeeded(){
    if (!craterOn) return;
    if (crater) return;
    if (turnNo % craterSpawnEvery !== 0) return;
    const pos = chooseCraterSpawn();
    if (!pos) return;
    crater = pos;
    board[crater.r][crater.c] = 'X';
    craterSpawnedAtTurn = turnNo;
    toast("A crater forms in deep space.");
    log.push(`☄ Crater formed at ${coordLabel(crater.r, crater.c)}.`);
  }
  function driftCraterOneStep(){
    if (!craterOn || !crater) return;
    // Attempt to move one step toward center (rounded direction).
    const cr = (N-1)/2, cc = (N-1)/2;
    const dr = cr - crater.r;
    const dc = cc - crater.c;
    const stepR = dr===0 ? 0 : (dr>0 ? 1 : -1);
    const stepC = dc===0 ? 0 : (dc>0 ? 1 : -1);

    const candidates = [];
    if (stepR!==0 || stepC!==0) candidates.push([crater.r + stepR, crater.c + stepC]);
    if (stepR!==0) candidates.push([crater.r + stepR, crater.c]);
    if (stepC!==0) candidates.push([crater.r, crater.c + stepC]);

    for (const [nr,nc] of candidates){
      if (!inb(nr,nc)) continue;
      if (board[nr][nc] === null){
        // Move crater
        board[crater.r][crater.c] = null;
        crater = {r:nr, c:nc};
        board[nr][nc] = 'X';
        log.push(`☄ Crater drifted to ${coordLabel(nr,nc)}.`);
        return;
      }
    }
    // If blocked, it stays.
  }

  // -------- AI (White) --------
  function evalMoveHeuristic(r,c, flips, player){
    // Heuristic: maximize flips + mobility (reduce opponent mobility), plus corners, avoid giving corners.
    const opp = other(player);
    let score = flips.length;

    // Corner bonus
    const isCorner = (r===0 && c===0) || (r===0 && c===N-1) || (r===N-1 && c===0) || (r===N-1 && c===N-1);
    if (isCorner) score += 20;

    // Clone board and apply
    const saved = board[r][c];
    board[r][c] = player;
    for (const [rr,cc] of flips) board[rr][cc] = player;

    // Mobility component
    const myMob = legalMovesFor(player).size;
    const opMob = legalMovesFor(opp).size;
    score += (myMob - opMob) * 0.7;

    // Restore (cheap restore: re-clone from snapshot for correctness)
    // Safer to use snapshot because flips overwrote.
    // We'll do snapshot externally; this function assumes caller uses snapshot.
    board[r][c] = saved;
    return score;
  }

  function chooseAIMove(){
    const player = 'W';
    const moves = legalMovesFor(player);
    if (moves.size === 0) return null;

    // Snapshot once for restoring by re-clone inside loop
    const snapshot = cloneBoard(board);

    let best = null;
    let bestScore = -1e9;
    for (const [key, flips] of moves.entries()){
      const [r,c] = key.split(',').map(Number);
      // Restore snapshot
      board = cloneBoard(snapshot);

      // Evaluate using real application
      board[r][c] = player;
      for (const [rr,cc] of flips) board[rr][cc] = player;

      // Score: flips + corner + mobility
      let score = flips.length;

      const isCorner = (r===0 && c===0) || (r===0 && c===N-1) || (r===N-1 && c===0) || (r===N-1 && c===N-1);
      if (isCorner) score += 25;

      // Avoid squares adjacent to empty corners (classic trap) if corner still empty
      const nearCornerPenalty = [
        {corner:[0,0], adj:[[0,1],[1,0],[1,1]]},
        {corner:[0,N-1], adj:[[0,N-2],[1,N-1],[1,N-2]]},
        {corner:[N-1,0], adj:[[N-2,0],[N-1,1],[N-2,1]]},
        {corner:[N-1,N-1], adj:[[N-2,N-1],[N-1,N-2],[N-2,N-2]]},
      ];
      for (const nc of nearCornerPenalty){
        const [cr,cc] = nc.corner;
        if (board[cr][cc] === null){ // still empty corner
          for (const [ar,ac] of nc.adj){
            if (ar===r && ac===c) score -= 8;
          }
        }
      }

      const myMob = legalMovesFor(player).size;
      const opMob = legalMovesFor('B').size;
      score += (myMob - opMob) * 0.9;

      // Small central preference early
      const centerBias = 2.2 - distToCenter(r,c);
      score += (turnNo < 16 ? centerBias * 0.25 : 0);

      if (score > bestScore){
        bestScore = score;
        best = {r,c, flips};
      }
    }

    // Restore snapshot fully before returning
    board = cloneBoard(snapshot);
    return best;
  }

  function maybeAIMove(){
    if (modeSel.value !== 'ai') return;
    if (current !== 'W') return;

    const moves = legalMovesFor('W');
    if (moves.size === 0){
      // pass
      doPass();
      return;
    }

    statusPill.textContent = "AI is thinking…";
    setTimeout(() => {
      const best = chooseAIMove();
      if (!best){ doPass(); return; }
      onMove(best.r, best.c, best.flips, true);
    }, 280);
  }

  // -------- Move flow --------
  function onCell(r,c){
    // If curtain is up, ignore
    if (curtainEl.classList.contains('on')) return;

    const nebulaOn = nebulaChk.checked;
    // if fog-of-war and cell not visible, block clicks
    const moves = legalMovesFor(current);
    if (nebulaOn){
      const vis = computeVisible(current, moves);
      if (!vis[r][c]) { toast("Hidden by the nebula."); return; }
    }

    const key = r+","+c;
    if (!moves.has(key)){
      toast("Not a legal move.");
      return;
    }
    onMove(r,c, moves.get(key), false);
  }

  function onMove(r,c, flips, byAI){
    // Crater squares are non-empty; legalMoves already prevents placement there.
    pushHistory(`Move ${coordLabel(r,c)}`);
    applyMove(r,c, flips);
    lastMove = {r,c, flips: flips.length, player: current};
    log.push(`${current==='B'?'●':'○'} ${current==='B'?'Black':'White'} → ${coordLabel(r,c)} (+${flips.length} flips)`);

    // Animate flips if visible: we do a lightweight re-render and add flip class to affected discs.
    const affected = [[r,c], ...flips];
    render(false);
    animateFlip(affected);

    // Crater drift happens AFTER a move, before turn changes (feels like "space reacts")
    if (craterOn){
      if (crater) driftCraterOneStep();
      spawnCraterIfNeeded();
    }

    // Switch turn
    current = other(current);
    turnNo++;
    passes = 0; // reset passes when a move occurs
    showHints = false;

    // If next player has no moves, auto-pass
    const nextMoves = legalMovesFor(current);
    if (nextMoves.size === 0){
      doPass();
      return;
    }

    // Nebula hotseat curtain (only in hotseat)
    if (nebulaChk.checked && modeSel.value === 'hotseat' && !byAI){
      showCurtainForNext();
    } else {
      render(true);
      if (!endIfOver()) maybeAIMove();
    }
  }

  function animateFlip(coords){
    // Add flip class to discs that are present in visible region
    for (const [r,c] of coords){
      const cell = cellEls[r*N + c];
      const disc = cell.querySelector('.disc');
      if (disc){
        disc.classList.remove('flip');
        // Force reflow
        void disc.offsetWidth;
        disc.classList.add('flip');
      }
    }
  }

  function doPass(){
    pushHistory("Pass");
    passes++;
    log.push(`${current==='B'?'●':'○'} ${current==='B'?'Black':'White'} passes.`);
    toast(`${current==='B'?'Black':'White'} passes.`);
    current = other(current);
    turnNo++;

    // If both passed or no moves for both, end.
    render(true);
    if (endIfOver()) return;

    const moves = legalMovesFor(current);
    if (moves.size === 0){
      // second pass
      if (passes >= 1){
        pushHistory("Pass");
        log.push(`${current==='B'?'●':'○'} ${current==='B'?'Black':'White'} passes.`);
        render(true);
        endIfOver();
        return;
      }
      // keep passing until a move exists (rare with craters)
      doPass();
      return;
    }

    if (nebulaChk.checked && modeSel.value === 'hotseat'){
      showCurtainForNext();
    } else {
      if (!endIfOver()) maybeAIMove();
    }
  }

  function showCurtainForNext(){
    curtainEl.classList.add('on');
    const nextName = current === 'B' ? "Black" : "White";
    curtainText.textContent = `Next: ${nextName} (fog-of-war active)`;
    curtainDisc.classList.toggle('black', current==='B');
    curtainDisc.classList.toggle('white', current==='W');
    curtainPending = true;
  }

  revealBtn.addEventListener('click', () => {
    curtainEl.classList.remove('on');
    curtainPending = false;
    render(true);
    endIfOver();
    maybeAIMove();
  });

  // Buttons
  hintBtn.addEventListener('click', () => {
    showHints = !showHints;
    render(true);
  });
  undoBtn.addEventListener('click', () => {
    // In AI mode, undo twice to give back your turn (if possible)
    if (modeSel.value === 'ai'){
      popHistory();
      // if still AI to move, pop again
      if (current === 'W') popHistory();
    } else {
      popHistory();
    }
    toast("Undone.");
    render(true);
  });
  restartBtn.addEventListener('click', reset);

  modeSel.addEventListener('change', () => {
    // Reset on mode change for clarity
    toast("Mode changed. Restarting universe…");
    setTimeout(reset, 150);
  });

  nebulaChk.addEventListener('change', () => {
    // If Nebula turned off while curtain is up, close it
    if (!nebulaChk.checked) curtainEl.classList.remove('on');
    render(true);
  });

  craterChk.addEventListener('change', () => {
    craterOn = craterChk.checked;
    toast(craterOn ? "Crater Drift armed." : "Crater Drift disabled.");
    // Don't erase existing crater mid-game; just stop drifting/spawning
    render(true);
  });

  // Small UX: show quick instructions on load
  setTimeout(() => toast("Tip: Toggle Nebula + Crater Drift for the full weirdness."), 550);

  // Start
  reset();
})();
</script>
</body>
</html>
