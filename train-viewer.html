
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Calm GLB Viewer (Auto-load, Textures, No Ground Circle)</title>
  <style>
    :root{
      --bg0:#06131c; --bg1:#0b2735;
      --glass: rgba(255,255,255,.10);
      --glass2: rgba(255,255,255,.16);
      --stroke: rgba(255,255,255,.18);
      --text: rgba(255,255,255,.92);
      --muted: rgba(255,255,255,.65);
      --accent:#88d6ff;
      --shadow: rgba(0,0,0,.35);
      --radius: 18px;
    }
    html,body{
      height:100%; margin:0; overflow:hidden;
      background: radial-gradient(1200px 900px at 70% 10%, #164356 0%, var(--bg1) 35%, var(--bg0) 100%);
      color:var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
    }
    #app{ position:fixed; inset:0; }
    canvas{ position:absolute; inset:0; width:100vw; height:100vh; display:block; }

    .dock{
      position:absolute;
      left: clamp(12px, 2vw, 22px);
      bottom: clamp(12px, 2vw, 22px);
      width: min(780px, calc(100% - 24px));
      padding: 12px;
      border-radius: var(--radius);
      background: linear-gradient(180deg, var(--glass2), var(--glass));
      border: 1px solid var(--stroke);
      box-shadow: 0 18px 60px var(--shadow);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      display:flex; flex-direction:column; gap:10px;
      user-select:none;
    }
    .title{ display:flex; align-items:baseline; justify-content:space-between; gap:10px; }
    .title .name{ font-weight:750; font-size:13px; letter-spacing:.2px; }
    .title .status{
      font-size:12px; color:var(--muted);
      max-width: 72%;
      overflow:hidden; text-overflow:ellipsis; white-space:nowrap;
    }
    .row{ display:flex; align-items:center; gap:10px; flex-wrap:wrap; }

    button{
      border:1px solid rgba(255,255,255,.18);
      background: rgba(0,0,0,.12);
      color:var(--text);
      padding: 9px 12px;
      border-radius: 14px;
      cursor:pointer;
      font-weight: 650;
      letter-spacing: .2px;
      transition: background .2s ease, border-color .2s ease, transform .06s ease;
    }
    button:hover{ background: rgba(255,255,255,.10); border-color: rgba(255,255,255,.28); }
    button:active{ transform: translateY(1px); }
    button[disabled]{ opacity:.55; cursor:not-allowed; }

    .ctl{
      display:flex; align-items:center; gap:8px;
      padding: 8px 10px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.10);
    }
    .ctl label{ font-size:12px; color:var(--muted); }
    input[type="range"]{ width: 170px; accent-color: var(--accent); }
    .ctl .val{
      font-size:12px; color:var(--text);
      font-variant-numeric: tabular-nums;
      min-width: 44px; text-align:right;
    }

    .hint{
      font-size:12px; color:var(--muted);
      line-height:1.35;
      padding: 8px 10px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.08);
    }
    .kbd{
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size:11px; padding: 2px 6px; border-radius: 8px;
      border:1px solid rgba(255,255,255,.16);
      background: rgba(0,0,0,.14);
      color: rgba(255,255,255,.85);
    }

    .toast{
      position:absolute; left:50%; top: 14px; transform:translateX(-50%);
      padding: 10px 12px; border-radius: 999px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.25);
      color: rgba(255,255,255,.86);
      font-size: 12px;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      opacity:0; pointer-events:none;
      transition: opacity .18s ease;
      max-width:min(980px, calc(100% - 28px));
      white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
    }
    .toast.show{ opacity:1; }

    .drop{
      position:absolute; inset:0;
      display:flex; align-items:center; justify-content:center;
      background: rgba(0,0,0,.32);
      opacity:0; pointer-events:none;
      transition: opacity .15s ease;
    }
    .drop.on{ opacity:1; pointer-events:auto; }
    .drop .card{
      border-radius: 18px;
      border:1px dashed rgba(255,255,255,.30);
      background: rgba(0,0,0,.22);
      padding: 18px 20px;
      color: rgba(255,255,255,.88);
      box-shadow: 0 20px 60px rgba(0,0,0,.35);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      text-align:center;
    }

    #file{ display:none; }

    .fatal{
      position:absolute; inset:0;
      display:none;
      place-items:center;
      background: rgba(0,0,0,.35);
    }
    .fatal .card{
      width:min(860px, calc(100% - 28px));
      padding: 16px 18px;
      border-radius: 18px;
      border: 1px solid rgba(255,255,255,.18);
      background: rgba(0,0,0,.30);
      box-shadow: 0 18px 60px rgba(0,0,0,.35);
    }
    .fatal h2{ margin:0 0 8px; font-size:14px; }
    .fatal p{ margin:0; font-size:12px; color: rgba(255,255,255,.72); line-height:1.45; }
    .fatal code{ color:#9fe2ff; }
  </style>
</head>
<body>
<div id="app">
  <canvas id="c"></canvas>
  <div class="toast" id="toast"></div>

  <div class="drop" id="drop">
    <div class="card">
      Drop a <b>.glb</b> here<br/>
      <span style="color:rgba(255,255,255,.65);font-size:12px">Auto-load is enabled; drop replaces it</span>
    </div>
  </div>

  <div class="fatal" id="fatal">
    <div class="card">
      <h2>Viewer couldn’t start</h2>
      <p id="fatalMsg"></p>
    </div>
  </div>

  <input id="file" type="file" accept=".glb,model/gltf-binary" />

  <section class="dock" aria-label="Viewer controls">
    <div class="title">
      <div class="name">Calm GLB Viewer</div>
      <div class="status" id="status">Loading Three.js…</div>
    </div>

    <div class="row">
      <button id="btnReload" disabled>Reload default</button>
      <button id="btnLoad" disabled>Load local GLB</button>
      <button id="btnReset" disabled>Reset</button>
      <button id="btnFocus" disabled>Focus</button>
      <button id="btnFS">Fullscreen</button>

      <div class="ctl">
        <label>Exposure</label>
        <input id="exposure" type="range" min="0.3" max="2.2" step="0.01" value="1.20" disabled />
        <div class="val" id="exVal">1.00</div>
      </div>

      <div class="ctl">
        <label>Bloom</label>
        <input id="bloom" type="range" min="0.0" max="1.0" step="0.01" value="0.14" disabled />
        <div class="val" id="blVal">0.14</div>
      </div>
    </div>

    <div class="hint">
      Left-drag rotate • Wheel zoom • Right-drag pan • Click select • Double‑click focus<br/>
      Keys: <span class="kbd">R</span> reset • <span class="kbd">F</span> fullscreen • <span class="kbd">Esc</span> clear selection
    </div>
  </section>
</div>

<script>
(async () => {
  const $ = (id) => document.getElementById(id);
  const statusEl = $("status");
  const toast = $("toast");
  const drop = $("drop");
  const fatal = $("fatal");
  const fatalMsg = $("fatalMsg");

  // ---- CHANGE THIS if needed ----
  const DEFAULT_MODEL = "./assets/4000class.glb";

  function setStatus(msg){ statusEl.textContent = msg; }
  function showToast(msg, ms=2200){
    toast.textContent = msg;
    toast.classList.add("show");
    clearTimeout(showToast._t);
    showToast._t = setTimeout(()=>toast.classList.remove("show"), ms);
  }

  // --- Load only core three.min.js (no examples) with CDN fallback ---
  function loadScript(url){
    return new Promise((resolve, reject) => {
      const s = document.createElement("script");
      s.src = url;
      s.async = true;
      s.onload = () => resolve(url);
      s.onerror = () => reject(new Error("Failed: " + url));
      document.head.appendChild(s);
    });
  }
  async function loadFromFallbacks(urls){
    let last;
    for (const u of urls){
      try { await loadScript(u); return u; } catch(e){ last = e; }
    }
    throw last || new Error("All fallbacks failed");
  }

  try{
    setStatus("Loading Three.js…");
    await loadFromFallbacks([
      "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js",
      "https://unpkg.com/three@0.160.0/build/three.min.js"
    ]);
    if (!window.THREE) throw new Error("THREE missing after load");
  } catch (e){
    console.error(e);
    fatal.style.display = "grid";
    fatalMsg.innerHTML =
      `Could not load <code>three.min.js</code>.<br><br>
       First failure: <code>${String(e.message).replace(/</g,"&lt;")}</code><br><br>
       If your network blocks CDNs completely, host <code>three.min.js</code> locally in the repo and load it with <code>&lt;script src="lib/three.min.js"&gt;&lt;/script&gt;</code>.`;
    setStatus("Failed to load Three.js");
    return;
  }

  // --- Enable UI ---
  const btnReload = $("btnReload");
  const btnLoad   = $("btnLoad");
  const btnReset  = $("btnReset");
  const btnFocus  = $("btnFocus");
  const btnFS     = $("btnFS");
  const fileInput = $("file");
  const exposureEl = $("exposure");
  const bloomEl    = $("bloom");
  const exVal = $("exVal");
  const blVal = $("blVal");

  [btnReload, btnLoad, btnReset, btnFocus, exposureEl, bloomEl].forEach(el => el.disabled = false);
  setStatus(`Ready (Three r${THREE.REVISION})`);

  // ---------- Renderer / scene ----------
  const canvas = $("c");
  const renderer = new THREE.WebGLRenderer({ canvas, antialias:true, alpha:false });
  renderer.setPixelRatio(Math.min(2, window.devicePixelRatio || 1));
  renderer.setSize(window.innerWidth, window.innerHeight, false);
  renderer.setClearColor(0x0b2735, 1); // brighter backdrop (canvas covers CSS bg)

  // We'll do tonemapping + output encoding ourselves in the final composite.
  renderer.toneMapping = THREE.NoToneMapping;
  renderer.outputColorSpace = THREE.LinearSRGBColorSpace;

  const scene = new THREE.Scene();

  const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.05, 6000);
  camera.position.set(2.2, 1.4, 3.2);

  // Calm lighting (no ground plane / no circle)
  scene.add(new THREE.HemisphereLight(0xaad8ff, 0x06131c, 0.68));
  scene.add(new THREE.AmbientLight(0xffffff, 0.10)); // lift shadows a touch

  const key = new THREE.DirectionalLight(0xfff2e3, 2.6);
  key.position.set(6, 10, 7);
  scene.add(key);

  const fill = new THREE.DirectionalLight(0xcfe9ff, 0.35);
  fill.position.set(-7, 7, -6);
  scene.add(fill);

  // ---------- Custom orbit controls (no OrbitControls.js needed) ----------
  const controls = {
    target: new THREE.Vector3(0, 0.6, 0),
    spherical: new THREE.Spherical(3.8, 1.15, 0.85),
    damping: 0.10,
    rotVel: new THREE.Vector2(0,0),
    panVel: new THREE.Vector2(0,0),
    zoomVel: 0,
    minDist: 0.4,
    maxDist: 2000
  };

  function updateCamera(){
    controls.spherical.theta += controls.rotVel.x;
    controls.spherical.phi   += controls.rotVel.y;
    controls.spherical.phi = Math.max(0.06, Math.min(Math.PI - 0.06, controls.spherical.phi));
    controls.spherical.radius = Math.max(
      controls.minDist,
      Math.min(controls.maxDist, controls.spherical.radius * (1.0 + controls.zoomVel))
    );

    controls.rotVel.multiplyScalar(1.0 - controls.damping);
    controls.panVel.multiplyScalar(1.0 - controls.damping);
    controls.zoomVel *= (1.0 - controls.damping);

    // Pan in camera plane
    if (controls.panVel.lengthSq() > 1e-12){
      const panSpeed = controls.spherical.radius * 0.0022;
      const x = -controls.panVel.x * panSpeed;
      const y =  controls.panVel.y * panSpeed;

      const forward = new THREE.Vector3();
      camera.getWorldDirection(forward);
      const right = new THREE.Vector3().crossVectors(forward, camera.up).normalize();
      const up = camera.up.clone().normalize();

      controls.target.addScaledVector(right, x);
      controls.target.addScaledVector(up, y);
    }

    const pos = new THREE.Vector3().setFromSpherical(controls.spherical).add(controls.target);
    camera.position.copy(pos);
    camera.lookAt(controls.target);
  }
  updateCamera();

  let isDown = false;
  let btn = 0;
  let lastX=0, lastY=0;

  canvas.addEventListener("contextmenu", (e)=>e.preventDefault());
  canvas.addEventListener("pointerdown", (e)=>{
    isDown = true;
    btn = e.button;
    lastX = e.clientX; lastY = e.clientY;
    canvas.setPointerCapture(e.pointerId);
  });
  canvas.addEventListener("pointerup", (e)=>{
    isDown = false;
    canvas.releasePointerCapture(e.pointerId);
  });
  canvas.addEventListener("pointermove", (e)=>{
    if (!isDown) return;
    const dx = e.clientX - lastX;
    const dy = e.clientY - lastY;
    lastX = e.clientX; lastY = e.clientY;

    if (btn === 2) { // right = pan
      controls.panVel.x += dx;
      controls.panVel.y += dy;
    } else { // left = rotate
      controls.rotVel.x += -dx * 0.0042;
      controls.rotVel.y += -dy * 0.0042;
    }
  });
  canvas.addEventListener("wheel", (e)=>{
    e.preventDefault();
    const s = Math.sign(e.deltaY);
    controls.zoomVel += s * 0.07;
  }, { passive:false });

  // ---------- Minimal GLB loader (enhanced image support) ----------
  function readU32(dv, o){ return dv.getUint32(o, true); }

  function decodeText(u8){
    return new TextDecoder("utf-8").decode(u8);
  }

  function accessorTypedArray(componentType){
    switch(componentType){
      case 5126: return Float32Array;
      case 5123: return Uint16Array;
      case 5125: return Uint32Array;
      case 5121: return Uint8Array;
      case 5122: return Int16Array;
      case 5120: return Int8Array;
      default: throw new Error("Unsupported componentType: " + componentType);
    }
  }
  function numComponents(type){
    switch(type){
      case "SCALAR": return 1;
      case "VEC2": return 2;
      case "VEC3": return 3;
      case "VEC4": return 4;
      case "MAT3": return 9;
      case "MAT4": return 16;
      default: throw new Error("Unsupported accessor type: " + type);
    }
  }

  async function loadGLB(arrayBuffer, baseURL){
    const dv = new DataView(arrayBuffer);
    const magic = readU32(dv, 0);
    if (magic !== 0x46546C67) throw new Error("Not a GLB file");
    const version = readU32(dv, 4);
    if (version !== 2) throw new Error("Unsupported glTF version: " + version);

    let offset = 12;
    let json = null;
    let binChunk = null;

    while (offset < arrayBuffer.byteLength){
      const chunkLen = readU32(dv, offset); offset += 4;
      const chunkType = readU32(dv, offset); offset += 4;
      const chunkData = new Uint8Array(arrayBuffer, offset, chunkLen);
      offset += chunkLen;

      if (chunkType === 0x4E4F534A) json = JSON.parse(decodeText(chunkData));      // JSON
      else if (chunkType === 0x004E4942) binChunk = chunkData;                    // BIN
    }

    if (!json) throw new Error("Missing JSON chunk");
    if (!binChunk) throw new Error("Missing BIN chunk");

    function sliceBufferView(bvIndex){
      const bv = json.bufferViews[bvIndex];
      const byteOffset = bv.byteOffset || 0;
      const byteLength = bv.byteLength;
      return binChunk.slice(byteOffset, byteOffset + byteLength);
    }

    async function loadImage(imageDef){
      // 1) Embedded in BIN via bufferView (common)
      if (imageDef.bufferView !== undefined){
        const bytes = sliceBufferView(imageDef.bufferView);
        const mime = imageDef.mimeType || "image/png";
        const blob = new Blob([bytes], { type: mime });
        const url = URL.createObjectURL(blob);
        const img = await new Promise((resolve, reject)=>{
          const i = new Image();
          i.onload = () => resolve(i);
          i.onerror = reject;
          i.src = url;
        });
        URL.revokeObjectURL(url);
        return img;
      }

      // 2) Data URI (embedded in JSON)
      if (typeof imageDef.uri === "string" && imageDef.uri.startsWith("data:")){
        const img = await new Promise((resolve, reject)=>{
          const i = new Image();
          i.onload = () => resolve(i);
          i.onerror = reject;
          i.src = imageDef.uri;
        });
        return img;
      }

      // 3) External image referenced by URI (rare for GLB, but possible)
      if (typeof imageDef.uri === "string"){
        const url = new URL(imageDef.uri, baseURL).toString();
        const img = await new Promise((resolve, reject)=>{
          const i = new Image();
          i.crossOrigin = "anonymous";
          i.onload = () => resolve(i);
          i.onerror = reject;
          i.src = url;
        });
        return img;
      }

      throw new Error("Unsupported image source (no bufferView and no uri)");
    }

    // Load images
    const images = new Array(json.images?.length || 0);
    if (json.images){
      for (let i=0; i<json.images.length; i++){
        images[i] = await loadImage(json.images[i]);
      }
    }

    // Create textures
    const textures = new Array(json.textures?.length || 0);
    if (json.textures){
      for (let i=0; i<json.textures.length; i++){
        const t = json.textures[i];
        const src = t.source;
        if (src === undefined) continue;
        const tex = new THREE.Texture(images[src]);
        tex.needsUpdate = true;
        tex.flipY = false;
        // Default wrapping/filtering is fine for most exports
        textures[i] = tex;
      }
    }

    // Materials
    const materials = new Array(json.materials?.length || 0);

    function textureInfoToTexture(texInfo, usage){
      if (!texInfo) return null;
      const tex = textures[texInfo.index];
      if (!tex) return null;
      // Color textures (baseColor/emissive) should be sRGB; others linear.
      tex.colorSpace = (usage === "srgb") ? THREE.SRGBColorSpace : THREE.LinearSRGBColorSpace;
      return tex;
    }

    if (json.materials){
      for (let i=0; i<json.materials.length; i++){
        const m = json.materials[i];
        const pbr = m.pbrMetallicRoughness || {};
        const mat = new THREE.MeshStandardMaterial();

        // base color factor
        if (pbr.baseColorFactor){
          mat.color.fromArray(pbr.baseColorFactor);
          mat.opacity = pbr.baseColorFactor[3] ?? 1.0;
          mat.transparent = mat.opacity < 1.0;
        }

        // base color texture
        const baseTex = textureInfoToTexture(pbr.baseColorTexture, "srgb");
        if (baseTex) mat.map = baseTex;

        // metallic-roughness texture (packed)
        const mrTex = textureInfoToTexture(pbr.metallicRoughnessTexture, "linear");
        if (mrTex){
          mat.metalnessMap = mrTex;  // uses B channel
          mat.roughnessMap = mrTex;  // uses G channel
        }

        mat.metalness = (pbr.metallicFactor !== undefined) ? pbr.metallicFactor : 1.0;
        mat.roughness = (pbr.roughnessFactor !== undefined) ? pbr.roughnessFactor : 1.0;

        // normal
        const nTex = textureInfoToTexture(m.normalTexture, "linear");
        if (nTex) mat.normalMap = nTex;

        // occlusion (AO)
        const oTex = textureInfoToTexture(m.occlusionTexture, "linear");
        if (oTex) mat.aoMap = oTex;
        if (m.occlusionTexture?.strength !== undefined) mat.aoMapIntensity = m.occlusionTexture.strength;

        // emissive
        if (m.emissiveFactor) mat.emissive.fromArray(m.emissiveFactor);
        const eTex = textureInfoToTexture(m.emissiveTexture, "srgb");
        if (eTex) mat.emissiveMap = eTex;

        // alpha modes
        if (m.alphaMode === "BLEND"){
          mat.transparent = true;
          mat.depthWrite = false;
        } else if (m.alphaMode === "MASK"){
          mat.alphaTest = (m.alphaCutoff !== undefined) ? m.alphaCutoff : 0.5;
        }

        mat.side = m.doubleSided ? THREE.DoubleSide : THREE.FrontSide;
        mat.needsUpdate = true;
        materials[i] = mat;
      }
    }

    function getMaterial(index){
      return (index !== undefined && materials[index]) ? materials[index] :
        new THREE.MeshStandardMaterial({ color: 0xcccccc, roughness: 0.9, metalness: 0.0 });
    }

    function getAccessorData(accIndex){
      const acc = json.accessors[accIndex];
      const bv = json.bufferViews[acc.bufferView];

      const byteOffset = (bv.byteOffset || 0) + (acc.byteOffset || 0);
      const componentCtor = accessorTypedArray(acc.componentType);
      const count = acc.count;
      const comps = numComponents(acc.type);
      const length = count * comps;

      const stride = bv.byteStride || 0;

      // Interleaved
      if (stride && stride !== comps * componentCtor.BYTES_PER_ELEMENT){
        const out = new componentCtor(length);
        const src = new Uint8Array(binChunk.buffer, binChunk.byteOffset + byteOffset, bv.byteLength - (acc.byteOffset || 0));
        const view = new DataView(src.buffer, src.byteOffset, src.byteLength);
        const bpc = componentCtor.BYTES_PER_ELEMENT;

        for (let i=0; i<count; i++){
          const base = i * stride;
          for (let c=0; c<comps; c++){
            const off = base + c * bpc;
            let v;
            if (acc.componentType === 5126) v = view.getFloat32(off, true);
            else if (acc.componentType === 5125) v = view.getUint32(off, true);
            else if (acc.componentType === 5123) v = view.getUint16(off, true);
            else if (acc.componentType === 5121) v = view.getUint8(off);
            else if (acc.componentType === 5122) v = view.getInt16(off, true);
            else if (acc.componentType === 5120) v = view.getInt8(off);
            out[i*comps + c] = v;
          }
        }
        return { array: out, itemSize: comps, normalized: !!acc.normalized };
      }

      // Non-interleaved
      const bytes = length * componentCtor.BYTES_PER_ELEMENT;
      const buf = binChunk.buffer.slice(binChunk.byteOffset + byteOffset, binChunk.byteOffset + byteOffset + bytes);
      const arr = new componentCtor(buf);
      return { array: arr, itemSize: comps, normalized: !!acc.normalized };
    }

    function buildMesh(meshDef){
      const group = new THREE.Group();
      const prims = meshDef.primitives || [];
      for (const prim of prims){
        const geom = new THREE.BufferGeometry();
        const attrs = prim.attributes || {};
        if (attrs.POSITION === undefined) continue;

        const pos = getAccessorData(attrs.POSITION);
        geom.setAttribute("position", new THREE.BufferAttribute(pos.array, pos.itemSize, pos.normalized));

        if (attrs.NORMAL !== undefined){
          const n = getAccessorData(attrs.NORMAL);
          geom.setAttribute("normal", new THREE.BufferAttribute(n.array, n.itemSize, n.normalized));
        } else {
          geom.computeVertexNormals();
        }

        if (attrs.TEXCOORD_0 !== undefined){
          const uv = getAccessorData(attrs.TEXCOORD_0);
          geom.setAttribute("uv", new THREE.BufferAttribute(uv.array, uv.itemSize, uv.normalized));
        }

        if (attrs.TEXCOORD_1 !== undefined){
          const uv2 = getAccessorData(attrs.TEXCOORD_1);
          geom.setAttribute("uv2", new THREE.BufferAttribute(uv2.array, uv2.itemSize, uv2.normalized));
        } else if (geom.getAttribute("uv")){
          // AO uses uv2; if absent, copy uv as a fallback
          const uv = geom.getAttribute("uv");
          geom.setAttribute("uv2", new THREE.BufferAttribute(uv.array, uv.itemSize, uv.normalized));
        }

        if (prim.indices !== undefined){
          const idx = getAccessorData(prim.indices);
          geom.setIndex(new THREE.BufferAttribute(idx.array, 1, idx.normalized));
        }

        geom.computeBoundingSphere();

        const mat = getMaterial(prim.material);
        const mesh = new THREE.Mesh(geom, mat);
        mesh.castShadow = false;
        mesh.receiveShadow = false;
        group.add(mesh);
      }
      return group;
    }

    // Build node hierarchy
    const nodeObjs = new Array(json.nodes?.length || 0);

    function nodeToObject(i){
      if (nodeObjs[i]) return nodeObjs[i];
      const n = json.nodes[i];
      const obj = new THREE.Object3D();
      obj.name = n.name || "";

      if (n.matrix){
        const m = new THREE.Matrix4().fromArray(n.matrix);
        obj.applyMatrix4(m);
      } else {
        if (n.translation) obj.position.fromArray(n.translation);
        if (n.rotation) obj.quaternion.fromArray(n.rotation);
        if (n.scale) obj.scale.fromArray(n.scale);
      }

      if (n.mesh !== undefined && json.meshes){
        const m = buildMesh(json.meshes[n.mesh]);
        if (!obj.name && n.name) m.name = n.name;
        obj.add(m);
      }

      if (n.children){
        for (const c of n.children){
          obj.add(nodeToObject(c));
        }
      }

      nodeObjs[i] = obj;
      return obj;
    }

    const outScene = new THREE.Group();
    outScene.name = "GLBScene";

    const sceneIndex = (json.scene !== undefined) ? json.scene : 0;
    const sc = (json.scenes && json.scenes[sceneIndex]) ? json.scenes[sceneIndex] : null;
    if (!sc) throw new Error("No default scene in GLB");
    if (sc.nodes){
      for (const ni of sc.nodes){
        outScene.add(nodeToObject(ni));
      }
    }

    return outScene;
  }

  // ---------- Selection ----------
  const raycaster = new THREE.Raycaster();
  const pointer = new THREE.Vector2();
  let root = null;
  let selected = null;

  // Selection rendering:
  // - BoxHelper avoids tinting/shrouding the whole mesh.
  // - You can re-enable emissive tint by flipping this flag.
  const USE_EMISSIVE_HIGHLIGHT = false;
  let selectionHelper = null;

  function disposeHelper(){
    if (!selectionHelper) return;
    scene.remove(selectionHelper);
    selectionHelper.geometry?.dispose?.();
    selectionHelper.material?.dispose?.();
    selectionHelper = null;
  }

  function clearSelection(){
    if (!selected && !selectionHelper) return;

    // restore emissive if we used it
    if (USE_EMISSIVE_HIGHLIGHT && selected){
      const st = selected.userData.__orig;
      if (st?.materials){
        st.materials.forEach(({mat, emissive, emissiveIntensity})=>{
          if (mat?.emissive){
            mat.emissive.copy(emissive);
            mat.emissiveIntensity = emissiveIntensity;
          }
        });
      }
    }

    disposeHelper();
    selected = null;
    showToast("Selection cleared", 900);
    setStatus(root ? "Model loaded" : `Ready (Three r${THREE.REVISION})`);
  }

  function highlight(obj){
    clearSelection();
    selected = obj;

    if (USE_EMISSIVE_HIGHLIGHT){
      // Subtle tint (much less 'blue shroud')
      const materials = [];
      obj.traverse((n)=>{
        if (!n.isMesh || !n.material) return;
        const mats = Array.isArray(n.material) ? n.material : [n.material];
        mats.forEach(mat=>{
          if (!mat?.emissive) return;
          materials.push({ mat, emissive: mat.emissive.clone(), emissiveIntensity: mat.emissiveIntensity ?? 1.0 });
          mat.emissive.setHex(0x0c1f2a);
          mat.emissiveIntensity = 0.25;
        });
      });
      obj.userData.__orig = { materials };
    } else {
      // Non-invasive highlight
      selectionHelper = new THREE.BoxHelper(obj, 0x88d6ff);
      selectionHelper.material.transparent = true;
      selectionHelper.material.opacity = 0.85;
      selectionHelper.material.depthTest = false; // stays visible
      selectionHelper.renderOrder = 999;
      scene.add(selectionHelper);
    }

    setStatus(`Selected: ${obj.name || "mesh"}`);
  }

  function pick(e){
    if (!root) return;
    const rect = canvas.getBoundingClientRect();
    pointer.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
    pointer.y = -(((e.clientY - rect.top) / rect.height) * 2 - 1);
    raycaster.setFromCamera(pointer, camera);

    const hits = raycaster.intersectObject(root, true);

    // Click empty space = clear selection (no Esc required)
    if (!hits.length){
      clearSelection();
      return;
    }

    const hit = hits[0].object;

    // Clicking the same mesh toggles selection off
    if (hit === selected){
      clearSelection();
      return;
    }

    highlight(hit);
    showToast(`Selected: ${hit.name || "mesh"}`, 1200);
  }

  canvas.addEventListener("click", pick);
  canvas.addEventListener("dblclick", (e)=>{ pick(e); focus(selected || root); });

// ---------- Frame / focus ----------
  function frameObject(obj){
    const box = new THREE.Box3().setFromObject(obj);
    const size = new THREE.Vector3(); box.getSize(size);
    const center = new THREE.Vector3(); box.getCenter(center);

    obj.position.sub(center);

    const maxDim = Math.max(size.x, size.y, size.z);
    const fitDist = maxDim / (2 * Math.tan(THREE.MathUtils.degToRad(camera.fov * 0.5)));
    const dist = Math.max(1.0, fitDist * 1.35);

    controls.spherical.radius = dist * 1.15;
    controls.spherical.phi = 1.10;
    controls.spherical.theta = 0.85;
    controls.target.set(0, Math.max(0.15, size.y * 0.12), 0);

    camera.near = Math.max(0.05, dist / 200);
    camera.far  = Math.max(200, dist * 300);
    camera.updateProjectionMatrix();

    updateCamera();

    if (selectionHelper) selectionHelper.update();
  }

  function focus(obj){
    if (!obj) return;
    const box = new THREE.Box3().setFromObject(obj);
    const size = new THREE.Vector3(); box.getSize(size);
    const center = new THREE.Vector3(); box.getCenter(center);

    controls.target.copy(center);
    const maxDim = Math.max(size.x, size.y, size.z);
    controls.spherical.radius = Math.max(0.6, maxDim * 1.5);
    updateCamera();

    if (selectionHelper) selectionHelper.update();
    showToast("Focused");
  }

  // ---------- Manual bloom + tonemapping pipeline ----------
  let rtScene, rtBright, rtBlurA, rtBlurB;
  let quadScene, quadCam, quadMesh;

  const quadVS = `
    varying vec2 vUv;
    void main(){
      vUv = uv;
      gl_Position = vec4(position.xy, 0.0, 1.0);
    }
  `;

  const brightFS = `
    precision highp float;
    varying vec2 vUv;
    uniform sampler2D tScene;
    uniform float threshold;
    void main(){
      vec3 c = texture2D(tScene, vUv).rgb;
      float lum = dot(c, vec3(0.2126, 0.7152, 0.0722));
      vec3 outc = (lum > threshold) ? c : vec3(0.0);
      gl_FragColor = vec4(outc, 1.0);
    }
  `;

  const blurFS = `
    precision highp float;
    varying vec2 vUv;
    uniform sampler2D tIn;
    uniform vec2 dir;
    void main(){
      vec3 sum = vec3(0.0);
      sum += texture2D(tIn, vUv - 2.0*dir).rgb * 0.07027;
      sum += texture2D(tIn, vUv - 1.0*dir).rgb * 0.31622;
      sum += texture2D(tIn, vUv).rgb            * 0.22703;
      sum += texture2D(tIn, vUv + 1.0*dir).rgb * 0.31622;
      sum += texture2D(tIn, vUv + 2.0*dir).rgb * 0.07027;
      gl_FragColor = vec4(sum, 1.0);
    }
  `;

  const compositeFS = `
    precision highp float;
    varying vec2 vUv;
    uniform sampler2D tScene;
    uniform sampler2D tBloom;
    uniform float bloomStrength;
    uniform float exposure;

    vec3 acesFilm(vec3 x){
      const float a = 2.51;
      const float b = 0.03;
      const float c = 2.43;
      const float d = 0.59;
      const float e = 0.14;
      return clamp((x*(a*x+b)) / (x*(c*x+d)+e), 0.0, 1.0);
    }

    vec3 linearToSRGB(vec3 c){
      return pow(max(c, 0.0), vec3(1.0/2.2));
    }

    void main(){
      vec3 sceneCol = texture2D(tScene, vUv).rgb;
      vec3 bloomCol = texture2D(tBloom, vUv).rgb;
      vec3 c = sceneCol + bloomCol * bloomStrength;
      c *= exposure;
      c = acesFilm(c);
      c = linearToSRGB(c);
      gl_FragColor = vec4(c, 1.0);
    }
  `;

  function makeRT(w,h){
    return new THREE.WebGLRenderTarget(w, h, {
      format: THREE.RGBAFormat,
      type: THREE.HalfFloatType,
      depthBuffer: true,
      stencilBuffer: false
    });
  }

  function rebuildPost(){
    const dpr = Math.min(2, window.devicePixelRatio || 1);
    const w = Math.max(2, Math.floor(window.innerWidth * dpr));
    const h = Math.max(2, Math.floor(window.innerHeight * dpr));

    rtScene?.dispose(); rtBright?.dispose(); rtBlurA?.dispose(); rtBlurB?.dispose();

    rtScene  = makeRT(w, h);
    const hw = Math.max(2, Math.floor(w * 0.5));
    const hh = Math.max(2, Math.floor(h * 0.5));
    rtBright = makeRT(hw, hh);
    rtBlurA  = makeRT(hw, hh);
    rtBlurB  = makeRT(hw, hh);

    quadScene = new THREE.Scene();
    quadCam = new THREE.Camera();
    quadMesh = new THREE.Mesh(new THREE.PlaneGeometry(2,2), new THREE.MeshBasicMaterial());
    quadScene.add(quadMesh);
  }

  const matBright = new THREE.ShaderMaterial({
    vertexShader: quadVS,
    fragmentShader: brightFS,
    uniforms: { tScene:{value:null}, threshold:{value:1.0} }
  });

  const matBlur = new THREE.ShaderMaterial({
    vertexShader: quadVS,
    fragmentShader: blurFS,
    uniforms: { tIn:{value:null}, dir:{value:new THREE.Vector2(0,0)} }
  });

  const matComposite = new THREE.ShaderMaterial({
    vertexShader: quadVS,
    fragmentShader: compositeFS,
    uniforms: {
      tScene:{value:null},
      tBloom:{value:null},
      bloomStrength:{value:0.14},
      exposure:{value:1.0}
    }
  });

  rebuildPost();

  function syncUI(){
    matComposite.uniforms.exposure.value = parseFloat(exposureEl.value);
    matComposite.uniforms.bloomStrength.value = parseFloat(bloomEl.value);
    exVal.textContent = (+exposureEl.value).toFixed(2);
    blVal.textContent = (+bloomEl.value).toFixed(2);
  }
  exposureEl.addEventListener("input", syncUI);
  bloomEl.addEventListener("input", syncUI);
  syncUI();

  // ---------- Model loading (auto + local + dragdrop) ----------
  async function loadFromURL(url){
    setStatus("Auto-loading model…");
    showToast("Loading model…");
    const resolved = new URL(url, window.location.href).toString();
    const res = await fetch(resolved, { cache: "no-store" });
    if (!res.ok) throw new Error(`Fetch failed: ${res.status} ${res.statusText}`);
    const ab = await res.arrayBuffer();

    // Quick LFS pointer / HTML error page detection
    if (ab.byteLength < 4000){
      const text = new TextDecoder().decode(new Uint8Array(ab));
      if (text.includes("git-lfs.github.com/spec")) throw new Error("This looks like a Git LFS pointer file, not the real GLB binary.");
      if (text.toLowerCase().includes("<html")) throw new Error("Fetched HTML instead of GLB. Check the path.");
    }

    const obj = await loadGLB(ab, resolved);
    if (root) scene.remove(root);
    root = obj;
    scene.add(root);
    clearSelection();
    frameObject(root);
    setStatus(url);
    showToast("Loaded ✔", 1600);
  }

  async function loadFromFile(file){
    if (!file) return;
    if (!file.name.toLowerCase().endsWith(".glb")){
      showToast("Please choose a .glb file.", 2400);
      return;
    }
    setStatus("Loading local GLB…");
    showToast("Loading…");
    const ab = await file.arrayBuffer();
    const obj = await loadGLB(ab, window.location.href);
    if (root) scene.remove(root);
    root = obj;
    scene.add(root);
    clearSelection();
    frameObject(root);
    setStatus(file.name);
    showToast("Loaded ✔", 1600);
  }

  btnReload.addEventListener("click", ()=> loadFromURL(DEFAULT_MODEL).catch(err=>{
    console.error(err);
    setStatus("Auto-load failed (see console)");
    showToast(String(err.message || err), 6000);
  }));
  btnLoad.addEventListener("click", ()=> fileInput.click());
  fileInput.addEventListener("change", (e)=> loadFromFile(e.target.files?.[0]).catch(console.error));

  btnReset.addEventListener("click", ()=>{
    if (root) frameObject(root);
    showToast("Reset");
  });

  btnFocus.addEventListener("click", ()=> focus(selected || root));

  btnFS.addEventListener("click", ()=>{
    if (!document.fullscreenElement) document.documentElement.requestFullscreen?.();
    else document.exitFullscreen?.();
  });

  // Drag & drop
  function showDrop(on){ drop.classList.toggle("on", !!on); }
  window.addEventListener("dragenter", (e)=>{ e.preventDefault(); showDrop(true); });
  window.addEventListener("dragover",  (e)=>{ e.preventDefault(); showDrop(true); });
  window.addEventListener("dragleave", (e)=>{
    if (e.target === document.documentElement || e.target === document.body) showDrop(false);
  });
  window.addEventListener("drop", (e)=>{
    e.preventDefault(); showDrop(false);
    const f = e.dataTransfer?.files?.[0];
    if (f) loadFromFile(f).catch(err => {
      console.error(err);
      showToast("Load failed (see console)", 4000);
    });
  });

  // Keyboard
  window.addEventListener("keydown", (e)=>{
    const k = e.key.toLowerCase();
    if (k === "r") btnReset.click();
    if (k === "f") btnFS.click();
    if (k === "escape") clearSelection();
  });

  // Resize
  function onResize(){
    renderer.setPixelRatio(Math.min(2, window.devicePixelRatio || 1));
    renderer.setSize(window.innerWidth, window.innerHeight, false);
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    rebuildPost();
  }
  window.addEventListener("resize", onResize, { passive:true });

  // Render loop
  const clock = new THREE.Clock();

  function render(){
    // subtle idle motion if nothing selected
    if (root && !selected){
      const t = clock.getElapsedTime();
      root.rotation.y = Math.sin(t * 0.08) * 0.02;
    }

    updateCamera();

    if (selectionHelper) selectionHelper.update();

    // 1) scene -> rtScene
    renderer.setRenderTarget(rtScene);
    renderer.clear();
    renderer.render(scene, camera);

    // 2) bright extract -> rtBright
    quadMesh.material = matBright;
    matBright.uniforms.tScene.value = rtScene.texture;
    matBright.uniforms.threshold.value = 1.0;
    renderer.setRenderTarget(rtBright);
    renderer.clear();
    renderer.render(quadScene, quadCam);

    // 3) blur H -> rtBlurA
    quadMesh.material = matBlur;
    matBlur.uniforms.tIn.value = rtBright.texture;
    matBlur.uniforms.dir.value.set(1.0 / rtBright.width, 0.0);
    renderer.setRenderTarget(rtBlurA);
    renderer.clear();
    renderer.render(quadScene, quadCam);

    // 4) blur V -> rtBlurB
    matBlur.uniforms.tIn.value = rtBlurA.texture;
    matBlur.uniforms.dir.value.set(0.0, 1.0 / rtBright.height);
    renderer.setRenderTarget(rtBlurB);
    renderer.clear();
    renderer.render(quadScene, quadCam);

    // 5) composite -> screen
    quadMesh.material = matComposite;
    matComposite.uniforms.tScene.value = rtScene.texture;
    matComposite.uniforms.tBloom.value = rtBlurB.texture;

    renderer.setRenderTarget(null);
    renderer.clear();
    renderer.render(quadScene, quadCam);

    requestAnimationFrame(render);
  }

  // Start
  showToast("Auto-loading default model…", 2000);
  btnReload.click();
  render();

})();
</script>
</body>
</html>
